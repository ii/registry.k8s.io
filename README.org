#+TITLE: registry.k8s.io

#+begin_quote
Implementation proposals for registry.k8s.io
#+end_quote

* Background + Purpose
Kubernetes release artifacts are currently stored in [[https://k8s.gcr.io][k8s.gcr.io]] and [[https://storage.googleapis.com/kubernetes-release][gs://kubernetes-release]].
Distributions in the ecosystem tend to pull from these artifacts and images.

ii set up [[https://github.com/kubernetes/k8s.io/tree/main/images/public-log-asn-matcher][a pipeline]] for processing the [PII] logs from the Kubernetes public /GCS/ buckets, which shows the traffic overtime.
Pulling in this data and ASN data from multiple providers, the fields of source IP can be matched all the way to company name.
With this limited data access, members of [[https://github.com/kubernetes/community/tree/master/sig-k8s-infra][sig-k8s-infra]] are then able to engage in informed conversation with various credit providers.

To ensure funding is well-spent and high spenders share the load of traffic, distributing traffic to other credit providers is required.
One solution would be to redirect to different container registries based on source IP.
This repo contains several, rough implementations of this solution.

Once a solution is chosen, it will be fully-fedged out to support redirection based on a mapping of source IP => IP block => ASN => credit provider.
If a request is made from /registry.k8s.io/ inside a credit provider's infrastructure and the credit provider is included in a redirection policy,
the request will be redirected with a status code of 302 to the given credit provider.

The process described will save on artifact distribution costs and help the Kubernetes project spend better.

* Proposals
- [[./artifactserver/README.org][ArtifactServer]] :: existing k8s infra project, adapted for configuring and 302 redirecting; supports unified artifacts and registry redirection
- [[./envoy-lua-go/README.org][Envoy-Lua-Go]] :: earlier implementation using Envoy's HTTP Lua filter and an /external/ backend;
- [[./envoy-wasm/README.org][Envoy-WASM]] :: implementation using Envoy's HTTP WASM filter + WASM filter written in Go
- [[./nginx-njs/README.org][NGINX-njs]] :: implementation using NGINX's njs (JavaScript embedded functions)

* TODO Matching on ASN -> IP range
Vendor ASN data is located in [[https://github.com/kubernetes/k8s.io/tree/main/registry.k8s.io/infra/meta/asns][k8s.io/registry.k8s.io/infra/meta/asns]].
The YAML is formatted as
#+begin_src yaml
name: a-cool-name
redirectsTo:
  registry: registry.a-cool.site
  artifacts: artifacts.a-cool.site
asns:
  - 0
  - 0
  - 0
  - 0
#+end_src
or as go structs
#+begin_src go
type RedirectSource struct {
	Registry  string `json:"registry"`
	Artifacts string `json:"artifacts"`
}
type CreditProvider struct {
	Name        string         `json:"name"`
	RedirectsTo RedirectSource `json:"redirectsTo"`
	ASNs        []int          `json:"asns"`
	CIDRs       []*net.IPNet   `json:"-"`
}
#+end_src
More fields might include
- on call (email, name)
- active / inactive

ASNs will be cached in memory, retrieved from the repo
- [[https://pkg.go.dev/github.com/coreos/etcd/embed][etcd embedded]]
- [[https://github.com/hashicorp/go-memdb][go-memdb]]

ASNs will be resolved into IP ranges using ???
- a go-bgp package
  - https://github.com/osrg/gobgp
  - something new for querying
- a database with auto-populated data
- a repo

All of the ASN data from each provider will be pre-resolved into credit provider -> IP ranges =map[string][]string=.

IP ranges will match IP addresses using something like this
#+begin_src go
package main

import (
    "fmt"
    "log"
    "net"
)

func main() {
    cidrFromASN := "10.10.10.0/24"
    matchingIPString := "10.10.10.1"
    matchingIP := net.ParseIP(matchingIPString)
    nonMatchingIPString := "10.10.9.3"
    nonMatchingIP := net.ParseIP(nonMatchingIPString)

    _, cidrRange, err := net.ParseCIDR(cidrFromASN)
    if err != nil {
        log.Fatal(err)
    }

    fmt.Printf("%s contains %s? %v\n", cidrRange, matchingIP, cidrRange.Contains(matchingIP))
    fmt.Printf("%s contains %s? %v\n", cidrRange, nonMatchingIP, cidrRange.Contains(nonMatchingIP))
}
#+end_src

#+RESULTS:
#+begin_SRC example
10.10.10.0/24 contains 10.10.10.1? true
10.10.10.0/24 contains 10.10.9.3? false
#+end_SRC

Each request that comes in will have a source IP, through the RequestIP field or a /X-Real-Ip/ like header.

If there is a match on the IP range, then the credit provider's specified registy/artifact host will be used for the 302 redirect.

A later optimisation could be to remember each unique IP that matches to a credit provider's ASN cidr range,
then using a quickly mapped struct for redirecting.

Some pseudo-go code for this operation
#+begin_src go
// periodic precomputation of ASN to IP range here
// ...

// handle rewrite
func RedirectOperation(r *http.Request, w http.ResponseWriter) {
    sourceIP := r.RemoteAddr
    xRealIP := r.Header.Get("X-Real-Ip")
    if xRealIp != "" {
        sourceIP = xRealIP
    }
    var rewriteProvider CreditProvider = findGoogleProvider()
    for _, p := range providers {
        for _, cidr := range p.CIDRs {
            if cidr.Contains(sourceIP) {
                rewriteProvider = p
            }
        }
    }
    path := r.Header.Get("path")
    location := "https://" + rewriteProvider.RedirectTo.Registry + path
    w.Header.Set("location", rewriteProvider.RedirectTo.Registry)
    w.WriteHeader(302)
    w.Write([]byte(``))
}
#+end_src

Extra production-y things
- tests
- prometheus instrumentation
- opentelemetry instrumentation

This way of writing things can be applied to
- [[./artifactserver/README.org][ArtifactServer]],
- [[./envoy-lua-go/README.org][Envoy-Lua-Go]], and preferably
- [[./envoy-wasm/README.org][Envoy-WASM]]

* Notes
The solutions docs detailed above are set out to deploy easily on a [[https://pair.sharing.io][Pair instance]].
To deploy elsewhere, the images will need to be pushed to a registry and the manifests modified to point to another host.

* Links
- Umbrella issue :: https://github.com/kubernetes/k8s.io/issues/1834#issuecomment-943836836
